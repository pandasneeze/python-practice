# UNIT 26 세트 사용하기
세트는 합집합, 교집합, 차집합 등의 연산이 가능합니다. <br>
세트를 만드는 방법과 세트 메서드 사용 방법을 공부합니다.

## 세트 만들기
- `세트 = {값1, 값2, 값3}`
- 세트는 요소의 순서가 정해져 있지 않음(매번 출력할 때마다 순서가 다르게 나옴).
- 요소는 중복될 수 없음
- 리스트, 튜플, 딕셔너리와는 달리 []로 특정 요소만 출력할 수 없음
- `set(반복가능한객체)`로 세트를 만들 수 있음
- `set('apple')`과 같이 문자열을 넣으면 문자 하나 하나가 요소로 들어감
```
>>> a = set('apple')
>>> a
{'p', 'a', 'l', 'e'}
```
- `range()`를 넣으면 범위 내 숫자가 요소로 들어감
```
>>> b = set(range(5))
>>> b
{0, 1, 2, 3, 4}
```
- `set()`와 같이 아무것도 지정하지 않으면 빈 세트가 됨
- 리스트, 딕셔너리와 달리 세트 안에 세트를 넣을 수 없음
### (참고) 프로즌세트
- 프로즌세트는 내용을 변경할 수 없음
- 집합 연산, 요소 추가 또는 삭제, 메서드 사용 불가
- 세트 안에 세트를 넣을 때 사용
- `프로즌세트 = frozenset(반복가능한객체)`

## 세트에 특정 값이 있는지 확인하기
- `in` 연산자 사용: `값 in 세트`
- 없는지 확인하려면 `값 not in 세트`하면 됨

## 집합 연산 사용하기
- `|`: 합집합을 구함, `set.union` 메서드와 동작이 같음
```
>>> a = {1, 2, 3, 4}
>>> b = {3, 4, 5, 6}
>>> a | b
{1, 2, 3, 4, 5, 6}
>>> set.union(a, b)
{1, 2, 3, 4, 5, 6}
```
- `&`: 교집합을 구함, `set.intersection` 메서드와 동작이 같음
```
>>> a & b
{3, 4}
>>> set.intersection(a, b)
{3, 4}
```
- `-`: 차집합을 구함, `set.difference` 메서드와 동작이 같음
```
>>> a = {1, 2, 3, 4}
>>> b = {3, 4, 5, 6}
>>> a - b
{1, 2}
>>> set.difference(a, b)
{1, 2}
```
- `^`: 대칭자집합(두 집합 중 겹치지 않는 요소만 포함)을 구함, `set.symmetric_difference` 메서드와 동작이 같음
```
>>> a ^ b
{1, 2, 5, 6}
>>> set.symmetric_difference(a, b)
{1, 2, 5, 6}
```

## 연산 후 할당
- `|=`: 현재 세트에 다른 세트를 더함, `update` 메서드와 같음
```
>>> a
{1, 2, 3, 4}
>>> a |= {5}
>>> a
{1, 2, 3, 4, 5}
```
```
>>> a = {1, 2, 3, 4}
>>> a.update({5})
>>> a
{1, 2, 3, 4, 5}
```
- `&=`: 현재 세트와 다른 세트 중에서 겹치는 요소만 현재 세트에 저장, `intersection_update` 메서드와 같음
```
>>> a = {1, 2, 3, 4}
>>> a &= {0, 1, 2, 3, 4}    
>>> a
{1, 2, 3, 4}
>>> a.intersection_update({0, 1, 2, 3, 4}) 
>>> a
{1, 2, 3, 4}
```
- `-=`: 현재 세트에서 다른 세트를 뺌, `difference_update` 메서드와 같음
```
>>> a
{1, 2, 3, 4}
>>> a -= {3}
>>> a
{1, 2, 4}
>>> a = {1, 2, 3, 4}
>>> a.difference_update({3})
>>> a
{1, 2, 4}
```
- `^=`: 현재 세트와 다른 세트에서 겹치지 않는 요소만 저장, `symmetric_difference_update` 메서드와 같음
```
>>> a = {1, 2, 3, 4} 
>>> a ^= {3, 4, 5, 6}
>>> a
{1, 2, 5, 6}
>>> a = {1, 2, 3, 4}  
>>> a.symmetric_difference_update({3, 4, 5, 6})
>>> a
{1, 2, 5, 6}
```

## 부분집합과 상위집합 확인하기
- `<=`: 현재 세트가 다른 세트의 부분집합인지 확인, `issubset` 메서드와 같음
```
>>> a <= {1, 2, 3, 4}
True
>>> a.issubset({1, 2, 3, 4, 5})
True
```
- `<`: 현재 세트가 다른 세트의 진부분집합(부분집합이지만 같지는 않음)인지 확인, 메서드는 없음
```
>>> a = {1, 2, 3, 4}  
>>> a < {1, 2, 3, 4, 5}  
True
```
- `>=`: 현재 세트가 다른 세트의 상위집합인지 확인, `issuperset` 메서드와 같음
```
>>> a = {1, 2, 3, 4}    
>>> a >= {1, 2, 3, 4}
True
```
- `>`: 현재 세트가 다른 세트의 진상위집합(상위집합이지만 같지는 않음)인지 확인, 메서드는 없음
```
>>> a = {1, 2, 3, 4}  
>>> a > {1, 2, 3}    
True
```

## 세트가 같은지 다른지 확인
- `==`: 서로 같은지 확인
- 세트는 요소의 순서가 정해져 있지 않으므로 요소만 같으면 참임
- `!=`: 서로 다른지 확인

## 세트가 겹치지 않는지 확인
- `isdisjoint()`: 현재 세트가 다른 세트와 겹치지 않는지 확인하는 메서드
- 겹치지 않으면 True, 겹치면 False
```
>>> a = {1, 2, 3, 4}
>>> a.isdisjoint({5, 6, 7, 8})
True
```

## 세트를 조작하기
- `add(요소)`: 요소 추가
```
>>> a = {1, 2, 3, 4}
>>> a.add(5)
>>> a
{1, 2, 3, 4, 5}
```
- `remove(요소)`: 요소 삭제, 요소가 없으면 에러 발생
- `discard(요소)`: 요소 삭제, 요소가 없으면 그냥 넘어감
- `pop()`: 임의의 요소를 삭제하고 해당 요소를 반환함
```
>>> a = {1, 2, 3, 4}
>>> a.pop()
1
>>> a
{2, 3, 4}
```
- `clear()`: 모든 요소를 삭제
```
>>> a.clear()
>>> a
set()
```
- `len(세트)`: 요소의 개수를 구함

## 세트의 할당과 복사
- `b = a`와 같이 할당하면 얕은 복사가 됨
- `copy()` 메서드로 복사해야 깊은 복사가 됨
```
>>> a = {1, 2, 3, 4}
>>> b = a.copy()
```

## 반복문으로 세트의 요소를 모두 출력하기
- `for` 반복문 사용
```python
for 변수 in 세트:
    반복할 코드
```
- 예시: a의 모든 요소 출력
```python
a = {1, 2, 3, 4}
for i in a:
    print(i, end=' ')
```
* *결과*: `1 2 3 4`

## 세트 표현식 사용하기
- `{식 for 변수 in 반복가능한객체}`
- `set(식 for 변수 in 반복가능한객체)`
```
>>> a = {i for i in 'apple'}
>>> a
{'p', 'a', 'l', 'e'}
```
- `if` 조건문 사용: `{식 for 변수 in 반복가능한객체 if 조건식}`
- `set(식 for 변수 in 반복가능한객체 if 조건식)`
- 예: 'pineapple'에서 'a', 'p', 'l'을 제외한 문자들로 세트 생성
```
>>> a = {i for i in 'pineapple' if i not in 'apl'}
>>> a
{'n', 'i', 'e'}
```
- `if i not in 'apl'`은 `if i != 'a' and i != 'p' and i != 'l'`과 같음
